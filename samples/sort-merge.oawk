BEGIN {
  debug=1
  asciig0 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
}
{
  words[NR] = $0;

  # negative index is a marker of the end of sorted part
  idxs[NR] = -NR;
}
END {

  while (1) {

    # if ending markers are less than 2, we cannot merge anymore
    nmrks = 0;
    for (i = 1; i <= NR; i++) {
      if (idxs[i] < 0)
        nmrks ++;
    }
    if (nmrks < 2)
      break;


    i0 = 1;
    while (i0 < NR) {
      for (i1 = i0; i1 <= NR && 0 < idxs[i1]; i1++)
        ;

      if (NR <= i1)
        break;

      i2 = i1 + 1;
      for (i3 = i2; i3 <= NR && 0 < idxs[i3]; i3++)
        ;

      # merge [i0..i1] [i2..i3]
      if (debug)
        printf("  merge: [%d..%d][%d..%d]\n", i0, i1, i2, i3);

      # revert negated marks
      if (idxs[i1] < 0)
        idxs[i1] = - idxs[i1];
      if (idxs[i3] < 0)
        idxs[i3] = - idxs[i3];


      # merge [i0..i1] [i2..i3], output is mgd[]
      ia = i0;
      ib = i2;
      mi = 0;
      while (ia <= i1 && ib <= i3) {
        wa = words[idxs[ia]];
        wb = words[idxs[ib]];
        sa = length(wa);
        sb = length(wb);

        if (sa < sb)
          cmp = -1;
        else if (sa > sb)
          cmp = 1;
        else
          cmp = 0;

        for (ci = 1; ci <= sa && ci <= sb; ci++) {
          ca = substr(wa, ci, 1);
          cb = substr(wb, ci, 1);
          cpa = index(asciig0, ca);
          cpb = index(asciig0, cb);
          if (cpa == cpb)
            continue;
          else if (cpa < cpb)
            cmp = -1;
          else if (cpa > cpb)
            cmp = 1;

          break;
        }

        if (cmp == -1) {
          if (debug)
            printf("  pick #%d:%s\n", idxs[ia], wa);
          mi++;
          mgd[mi] = idxs[ia];
          ia++;
        } else if (cmp == 1) {
          if (debug)
            printf("  pick #%d:%s\n", idxs[ib], wb);
          mi++;
          mgd[mi] = idxs[ib];
          ib++;
        } else {
          if (debug) {
            printf("  pick #%d:%s\n", idxs[ia], wa);
            printf("  pick #%d:%s\n", idxs[ib], wb);
          }
          mi++;
          mgd[mi] = idxs[ia];
          ia++;
          mi++;
          mgd[mi] = idxs[ib];
          ib++;
        }
      }


      # append trailing data
      for (; ia <= i1; ia++) {
        if (0 < length(words[idxs[ia]])) {
          if (debug)
            printf("  pick #%d:%s\n", idxs[ia], words[idxs[ia]]);
          mi++;
          mgd[mi] = idxs[ia];
        }
      }

      for (; ib <= i1; ib++) {
        if (0 < length(words[idxs[ib]])) {
          if (debug)
            printf("  pick #%d:%s\n", idxs[ib], words[idxs[ib]]);
          mi++;
          mgd[mi] = idxs[ib];
        }
      }


      # write-back mgd[] to idxs[]
      for (d = 1; d <= mi; d++) {
        idxs[i0 + d - 1] = mgd[d];
      }


      # dump merged one
      if (debug) {
        for (j = i0; j <= i3; j++)
          printf("    words[%d] \"%s\"\n", idxs[j], words[idxs[j]]);
      }


      # revert the last entry
      idxs[i3] = - idxs[i3];

      i0 = i3 + 1;
    } # end of merge [i0..i1] [i2..i3]
  } # loop for markers more than 2

  # revert the last entry
  idxs[NR] = - idxs[NR];

  for (i = 1; i <= NR; i++)
    print words[idxs[i]];
}
